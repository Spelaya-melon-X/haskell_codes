Тут единственное интересное - это так Рекурсивные типы данных 


`MyList a `— полиморфный тип (работает с любым типом a)

Два конструктора:

- `Empty` — пустой список (аналог [])
- `Cons x xs` — элемент x и хвост списка xs (аналог x:xs)

пример : 
```haskell
list1 = Empty                          -- []
list2 = Cons 1 Empty                   -- [1]
list3 = Cons 1 (Cons 2 Empty)          -- [1,2]
```


### Реализация класса Show

```haskell
instance Show a => Show (MyList a) where
    show Empty = "Empty"
    show (Cons x xs) = "Cons " ++ show x ++ " " ++ show xs
```


Что делает: Позволяет печатать списки. Ограничение `Show a =>` означает, что элементы списка тоже должны быть печатаемыми.

то есть , `Show` позволяет предоставлять существующие типы в виде строк

Результат:

```haskell
show (Cons 1 (Cons 2 Empty))  -- "Cons 1 Cons 2 Empty"
```

### **Что делает класс `Show`:**

- Добавляет метод `show :: a -> String`
    
- Позволяет конвертировать значения в строки
    
- **Требует:** если тип параметризован (`MyList a`), то параметр `a` тоже должен иметь `Show`


### **`Cons` — это:**

- **Конструктор алгебраического типа данных**
    
- **Функция**, которая берёт элемент и список, возвращает новый список
    
- **Рекурсивная структура** для построения связных списков

``` md
Cons 1 (Cons 2 (Cons 3 Empty))
  │      │      │      │
  ▼      ▼      ▼      ▼
 [1] -> [2] -> [3] -> NULL
```
